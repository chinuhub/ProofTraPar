/* rti2code: autogenerated libFAUDES rti registration: libFAUDES 2.26g synthesis-observer-observability-diagnosis-hiosys-iosystem-multitasking-coordinationcontrol-pushdown-timed-simulator-iodevice-luabindings */

namespace faudes {
void LoadRegisteredTypes(void);
} // namespace
namespace faudes {
void LoadRegisteredFunctions(void);
} // namespace
namespace faudes {
/* Function class for C++ function Accessible*/
class Rti0Accessible : public Function { 
public:
Rti0Accessible(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti0Accessible(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant G:=Acc(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant GRes:=Acc(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant G:=Acc(G)
    Accessible(*mP_0_0); break; };
  case 1: { // variant GRes:=Acc(GArg)
    Accessible(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SetDifference*/
class Rti1SetDifference : public Function { 
public:
Rti1SetDifference(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti1SetDifference(pFuncDef); };
protected:
EventSet* mP_0_0;
EventSet* mP_0_1;
EventSet* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Sigma=Sigma1 - Sigma2
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Sigma=Sigma1 - Sigma2
    SetDifference(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SetEquality*/
class Rti2SetEquality : public Function { 
public:
Rti2SetEquality(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti2SetEquality(pFuncDef); };
protected:
EventSet* mP_0_0;
EventSet* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Sigma1 == Sigma2
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Sigma1 == Sigma2
    *(mP_0_2->CReference()) = SetEquality(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function AlphabetExtract*/
class Rti3AlphabetExtract : public Function { 
public:
Rti3AlphabetExtract(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti3AlphabetExtract(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Sigma(Gen)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Sigma(Gen)
    AlphabetExtract(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SetInclusion*/
class Rti4SetInclusion : public Function { 
public:
Rti4SetInclusion(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti4SetInclusion(pFuncDef); };
protected:
EventSet* mP_0_0;
EventSet* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Sigma1 <= Sigma2
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Sigma1 <= Sigma2
    *(mP_0_2->CReference()) = SetInclusion(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SetIntersection*/
class Rti5SetIntersection : public Function { 
public:
Rti5SetIntersection(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti5SetIntersection(pFuncDef); };
protected:
EventSet* mP_0_0;
EventSet* mP_0_1;
EventSet* mP_0_2;
EventSetVector* mP_1_0;
EventSet* mP_1_1;
GeneratorVector* mP_2_0;
EventSet* mP_2_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Sigma=Sigma1 ^ Sigma2
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Sigma = ^_i(Sigma_i)
    switch(n) { 
    case 0:     res=DoTypeCast<EventSetVector>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 2: { // variant Sigma = ^_i(Sigma(Gen_i))
    switch(n) { 
    case 0:     res=DoTypeCast<GeneratorVector>(0, mP_2_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_2_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Sigma=Sigma1 ^ Sigma2
    SetIntersection(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant Sigma = ^_i(Sigma_i)
    SetIntersection(*mP_1_0 ,*mP_1_1); break; };
  case 2: { // variant Sigma = ^_i(Sigma(Gen_i))
    SetIntersection(*mP_2_0 ,*mP_2_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function AlphabetLanguage*/
class Rti6AlphabetLanguage : public Function { 
public:
Rti6AlphabetLanguage(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti6AlphabetLanguage(pFuncDef); };
protected:
EventSet* mP_0_0;
Generator* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Sigma
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Sigma
    AlphabetLanguage(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SetUnion*/
class Rti7SetUnion : public Function { 
public:
Rti7SetUnion(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti7SetUnion(pFuncDef); };
protected:
EventSet* mP_0_0;
EventSet* mP_0_1;
EventSet* mP_0_2;
EventSetVector* mP_1_0;
EventSet* mP_1_1;
GeneratorVector* mP_2_0;
EventSet* mP_2_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Sigma=Sigma1 v Sigma2
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Sigma = v_i(Sigma_i)
    switch(n) { 
    case 0:     res=DoTypeCast<EventSetVector>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 2: { // variant Sigma = v_i(Sigma(Gen_i))
    switch(n) { 
    case 0:     res=DoTypeCast<GeneratorVector>(0, mP_2_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_2_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Sigma=Sigma1 v Sigma2
    SetUnion(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant Sigma = v_i(Sigma_i)
    SetUnion(*mP_1_0 ,*mP_1_1); break; };
  case 2: { // variant Sigma = v_i(Sigma(Gen_i))
    SetUnion(*mP_2_0 ,*mP_2_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function Automaton*/
class Rti8Automaton : public Function { 
public:
Rti8Automaton(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti8Automaton(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
EventSet* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Automaton(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Automaton(GArg, Sigma)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Automaton(GArg)
    Automaton(*mP_0_0); break; };
  case 1: { // variant Automaton(GArg, Sigma)
    Automaton(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function Coaccessible*/
class Rti9Coaccessible : public Function { 
public:
Rti9Coaccessible(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti9Coaccessible(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant G:=CoAcc(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant GRes:=CoAcc(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant G:=CoAcc(G)
    Coaccessible(*mP_0_0); break; };
  case 1: { // variant GRes:=CoAcc(GArg)
    Coaccessible(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function Complete*/
class Rti10Complete : public Function { 
public:
Rti10Complete(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti10Complete(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
Generator* mP_2_0;
EventSet* mP_2_1;
Generator* mP_3_0;
EventSet* mP_3_1;
Generator* mP_3_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant G:=Complete(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant GRes:=Complete(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 2: { // variant G:=Complete(G,SigmaO)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_2_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_2_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 3: { // variant GRes:=Complete(G,SigmaO)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_3_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_3_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_3_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant G:=Complete(G)
    Complete(*mP_0_0); break; };
  case 1: { // variant GRes:=Complete(G)
    Complete(*mP_1_0 ,*mP_1_1); break; };
  case 2: { // variant G:=Complete(G,SigmaO)
    Complete(*mP_2_0 ,*mP_2_1); break; };
  case 3: { // variant GRes:=Complete(G,SigmaO)
    Complete(*mP_3_0 ,*mP_3_1 ,*mP_3_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function ConDecExtension*/
class Rti11ConDecExtension : public Function { 
public:
Rti11ConDecExtension(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti11ConDecExtension(pFuncDef); };
protected:
System* mP_0_0;
EventSetVector* mP_0_1;
EventSet* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant ConDecExtension(gen,alphVector,ek)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSetVector>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant ConDecExtension(gen,alphVector,ek)
    ConDecExtension(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function DecentralizedDiagnoser*/
class Rti12DecentralizedDiagnoser : public Function { 
public:
Rti12DecentralizedDiagnoser(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti12DecentralizedDiagnoser(pFuncDef); };
protected:
System* mP_0_0;
Generator* mP_0_1;
EventSetVector* mP_0_2;
GeneratorVector* mP_0_3;
Boolean* mP_0_4;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant DecentralizedDiagnoser(GArg,KArg,AVArg,DVArg,BRes)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSetVector>(2, mP_0_2); break; 
    case 3:     res=DoTypeCast<GeneratorVector>(3, mP_0_3); break; 
    case 4:     res=DoTypeCast<Boolean>(4, mP_0_4); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant DecentralizedDiagnoser(GArg,KArg,AVArg,DVArg,BRes)
    *(mP_0_4->CReference()) = DecentralizedDiagnoser(*mP_0_0 ,*mP_0_1 ,*mP_0_2 ,*mP_0_3); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function DecentralizedModularDiagnoser*/
class Rti13DecentralizedModularDiagnoser : public Function { 
public:
Rti13DecentralizedModularDiagnoser(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti13DecentralizedModularDiagnoser(pFuncDef); };
protected:
SystemVector* mP_0_0;
Generator* mP_0_1;
GeneratorVector* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant DecentralizedModularDiagnoser(GVArg,KArg,DVArg)
    switch(n) { 
    case 0:     res=DoTypeCast<SystemVector>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<GeneratorVector>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant DecentralizedModularDiagnoser(GVArg,KArg,DVArg)
    DecentralizedModularDiagnoser(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function aDeterministic*/
class Rti14aDeterministic : public Function { 
public:
Rti14aDeterministic(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti14aDeterministic(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Deterministic(G,GRes)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Deterministic(G,GRes)
    aDeterministic(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function EmptyLanguage*/
class Rti15EmptyLanguage : public Function { 
public:
Rti15EmptyLanguage(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti15EmptyLanguage(pFuncDef); };
protected:
EventSet* mP_0_0;
Generator* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) := 0
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) := 0
    EmptyLanguage(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function EmptyStringLanguage*/
class Rti16EmptyStringLanguage : public Function { 
public:
Rti16EmptyStringLanguage(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti16EmptyStringLanguage(pFuncDef); };
protected:
EventSet* mP_0_0;
Generator* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = {epsilon}
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = {epsilon}
    EmptyStringLanguage(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function EventDiagnoser*/
class Rti17EventDiagnoser : public Function { 
public:
Rti17EventDiagnoser(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti17EventDiagnoser(pFuncDef); };
protected:
System* mP_0_0;
AttributeFailureTypeMap* mP_0_1;
Diagnoser* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant EventDiagnoser(Gen,FailureTypeMap,Diagnoser)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<AttributeFailureTypeMap>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Diagnoser>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant EventDiagnoser(Gen,FailureTypeMap,Diagnoser)
    EventDiagnoser(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function FullLanguage*/
class Rti18FullLanguage : public Function { 
public:
Rti18FullLanguage(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti18FullLanguage(pFuncDef); };
protected:
EventSet* mP_0_0;
Generator* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant L(GRes) = Sigma*
    switch(n) { 
    case 0:     res=DoTypeCast<EventSet>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant L(GRes) = Sigma*
    FullLanguage(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function HioFreeInput*/
class Rti19HioFreeInput : public Function { 
public:
Rti19HioFreeInput(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti19HioFreeInput(pFuncDef); };
protected:
HioPlant* mP_0_0;
HioController* mP_1_0;
HioEnvironment* mP_2_0;
HioConstraint* mP_3_0;
Generator* mP_4_0;
EventSet* mP_4_1;
EventSet* mP_4_2;
Generator* mP_4_3;
String* mP_4_4;
String* mP_4_5;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant HioFreeInput(Plant)
    switch(n) { 
    case 0:     res=DoTypeCast<HioPlant>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant HioFreeInput(Controller)
    switch(n) { 
    case 0:     res=DoTypeCast<HioController>(0, mP_1_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 2: { // variant HioFreeInput(Environment)
    switch(n) { 
    case 0:     res=DoTypeCast<HioEnvironment>(0, mP_2_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 3: { // variant HioFreeInput(Constraint)
    switch(n) { 
    case 0:     res=DoTypeCast<HioConstraint>(0, mP_3_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 4: { // variant HioFreeInput(GArg,U,Y,GRes,StrErr1,StrErr2)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_4_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_4_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_4_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_4_3); break; 
    case 4:     res=DoTypeCast<String>(4, mP_4_4); break; 
    case 5:     res=DoTypeCast<String>(5, mP_4_5); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant HioFreeInput(Plant)
    HioFreeInput(*mP_0_0); break; };
  case 1: { // variant HioFreeInput(Controller)
    HioFreeInput(*mP_1_0); break; };
  case 2: { // variant HioFreeInput(Environment)
    HioFreeInput(*mP_2_0); break; };
  case 3: { // variant HioFreeInput(Constraint)
    HioFreeInput(*mP_3_0); break; };
  case 4: { // variant HioFreeInput(GArg,U,Y,GRes,StrErr1,StrErr2)
    HioFreeInput(*mP_4_0 ,*mP_4_1 ,*mP_4_2 ,*mP_4_3 ,*(mP_4_4->CReference()) ,*(mP_4_5->CReference())); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function HioShuffle*/
class Rti20HioShuffle : public Function { 
public:
Rti20HioShuffle(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti20HioShuffle(pFuncDef); };
protected:
HioPlant* mP_0_0;
HioPlant* mP_0_1;
HioPlant* mP_0_2;
Generator* mP_1_0;
Generator* mP_1_1;
EventSet* mP_1_2;
EventSet* mP_1_3;
EventSet* mP_1_4;
EventSet* mP_1_5;
Generator* mP_1_6;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant GRes =  GArg1 ||_io GArg2
    switch(n) { 
    case 0:     res=DoTypeCast<HioPlant>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<HioPlant>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<HioPlant>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant GRes =  HioShuffle(...)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_1_2); break; 
    case 3:     res=DoTypeCast<EventSet>(3, mP_1_3); break; 
    case 4:     res=DoTypeCast<EventSet>(4, mP_1_4); break; 
    case 5:     res=DoTypeCast<EventSet>(5, mP_1_5); break; 
    case 6:     res=DoTypeCast<Generator>(6, mP_1_6); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant GRes =  GArg1 ||_io GArg2
    HioShuffle(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant GRes =  HioShuffle(...)
    HioShuffle(*mP_1_0 ,*mP_1_1 ,*mP_1_2 ,*mP_1_3 ,*mP_1_4 ,*mP_1_5 ,*mP_1_6); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function HioStatePartition*/
class Rti21HioStatePartition : public Function { 
public:
Rti21HioStatePartition(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti21HioStatePartition(pFuncDef); };
protected:
HioPlant* mP_0_0;
HioController* mP_1_0;
HioEnvironment* mP_2_0;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant HioStatePartition(Plant)
    switch(n) { 
    case 0:     res=DoTypeCast<HioPlant>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant HioStatePartition(Controller)
    switch(n) { 
    case 0:     res=DoTypeCast<HioController>(0, mP_1_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 2: { // variant HioStatePartition(Environment)
    switch(n) { 
    case 0:     res=DoTypeCast<HioEnvironment>(0, mP_2_0); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant HioStatePartition(Plant)
    HioStatePartition(*mP_0_0); break; };
  case 1: { // variant HioStatePartition(Controller)
    HioStatePartition(*mP_1_0); break; };
  case 2: { // variant HioStatePartition(Environment)
    HioStatePartition(*mP_2_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function HioSynth*/
class Rti22HioSynth : public Function { 
public:
Rti22HioSynth(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti22HioSynth(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
Generator* mP_0_3;
EventSet* mP_0_4;
EventSet* mP_0_5;
EventSet* mP_0_6;
EventSet* mP_0_7;
EventSet* mP_0_8;
EventSet* mP_0_9;
Generator* mP_0_10;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Core Synthesis Algorithm
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_0_3); break; 
    case 4:     res=DoTypeCast<EventSet>(4, mP_0_4); break; 
    case 5:     res=DoTypeCast<EventSet>(5, mP_0_5); break; 
    case 6:     res=DoTypeCast<EventSet>(6, mP_0_6); break; 
    case 7:     res=DoTypeCast<EventSet>(7, mP_0_7); break; 
    case 8:     res=DoTypeCast<EventSet>(8, mP_0_8); break; 
    case 9:     res=DoTypeCast<EventSet>(9, mP_0_9); break; 
    case 10:     res=DoTypeCast<Generator>(10, mP_0_10); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Core Synthesis Algorithm
    HioSynth(*mP_0_0 ,*mP_0_1 ,*mP_0_2 ,*mP_0_3 ,*mP_0_4 ,*mP_0_5 ,*mP_0_6 ,*mP_0_7 ,*mP_0_8 ,*mP_0_9 ,*mP_0_10); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function HioSynthHierarchical*/
class Rti23HioSynthHierarchical : public Function { 
public:
Rti23HioSynthHierarchical(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti23HioSynthHierarchical(pFuncDef); };
protected:
HioPlant* mP_0_0;
HioEnvironment* mP_0_1;
HioPlant* mP_0_2;
Generator* mP_0_3;
HioConstraint* mP_0_4;
HioConstraint* mP_0_5;
HioController* mP_0_6;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Hierarchical synthesis
    switch(n) { 
    case 0:     res=DoTypeCast<HioPlant>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<HioEnvironment>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<HioPlant>(2, mP_0_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_0_3); break; 
    case 4:     res=DoTypeCast<HioConstraint>(4, mP_0_4); break; 
    case 5:     res=DoTypeCast<HioConstraint>(5, mP_0_5); break; 
    case 6:     res=DoTypeCast<HioController>(6, mP_0_6); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Hierarchical synthesis
    HioSynthHierarchical(*mP_0_0 ,*mP_0_1 ,*mP_0_2 ,*mP_0_3 ,*mP_0_4 ,*mP_0_5 ,*mP_0_6); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function HioSynthMonolithic*/
class Rti24HioSynthMonolithic : public Function { 
public:
Rti24HioSynthMonolithic(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti24HioSynthMonolithic(pFuncDef); };
protected:
HioPlant* mP_0_0;
HioPlant* mP_0_1;
HioConstraint* mP_0_2;
HioConstraint* mP_0_3;
HioConstraint* mP_0_4;
HioController* mP_0_5;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Monolithic Synthesis
    switch(n) { 
    case 0:     res=DoTypeCast<HioPlant>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<HioPlant>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<HioConstraint>(2, mP_0_2); break; 
    case 3:     res=DoTypeCast<HioConstraint>(3, mP_0_3); break; 
    case 4:     res=DoTypeCast<HioConstraint>(4, mP_0_4); break; 
    case 5:     res=DoTypeCast<HioController>(5, mP_0_5); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Monolithic Synthesis
    HioSynthMonolithic(*mP_0_0 ,*mP_0_1 ,*mP_0_2 ,*mP_0_3 ,*mP_0_4 ,*mP_0_5); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function insertRelabeledEvents*/
class Rti25insertRelabeledEvents : public Function { 
public:
Rti25insertRelabeledEvents(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti25insertRelabeledEvents(pFuncDef); };
protected:
System* mP_0_0;
EventRelabelMap* mP_0_1;
System* mP_1_0;
EventRelabelMap* mP_1_1;
EventSet* mP_1_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Insert(Plant,RelabelMap)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventRelabelMap>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Insert(Plant,RelabelMap,SigmaNew)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventRelabelMap>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_1_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Insert(Plant,RelabelMap)
    insertRelabeledEvents(*mP_0_0 ,*mP_0_1); break; };
  case 1: { // variant Insert(Plant,RelabelMap,SigmaNew)
    insertRelabeledEvents(*mP_1_0 ,*mP_1_1 ,*mP_1_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IntegerSum*/
class Rti26IntegerSum : public Function { 
public:
Rti26IntegerSum(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti26IntegerSum(pFuncDef); };
protected:
Integer* mP_0_0;
Integer* mP_0_1;
Integer* mP_0_2;
IntegerVector* mP_1_0;
Integer* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IRes=I_1+I_2
    switch(n) { 
    case 0:     res=DoTypeCast<Integer>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Integer>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Integer>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant IRes=Sum_i I_i
    switch(n) { 
    case 0:     res=DoTypeCast<IntegerVector>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Integer>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IRes=I_1+I_2
    *(mP_0_2->CReference()) = IntegerSum(*(mP_0_0->CReference()) ,*(mP_0_1->CReference())); break; };
  case 1: { // variant IRes=Sum_i I_i
    *(mP_1_1->CReference()) = IntegerSum(*mP_1_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function aInvProject*/
class Rti27aInvProject : public Function { 
public:
Rti27aInvProject(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti27aInvProject(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
Generator* mP_1_0;
EventSet* mP_1_1;
Generator* mP_1_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant InvProject(G0,Sigma)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant InvProject(G0,Sigma,GRes)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_1_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant InvProject(G0,Sigma)
    aInvProject(*mP_0_0 ,*mP_0_1); break; };
  case 1: { // variant InvProject(G0,Sigma,GRes)
    aInvProject(*mP_1_0 ,*mP_1_1 ,*mP_1_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IoFreeInput*/
class Rti28IoFreeInput : public Function { 
public:
Rti28IoFreeInput(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti28IoFreeInput(pFuncDef); };
protected:
IoSystem* mP_0_0;
Generator* mP_1_0;
EventSet* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IoFreeInput(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<IoSystem>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant IoFreeInput(GArg,SigU)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IoFreeInput(GArg)
    IoFreeInput(*mP_0_0); break; };
  case 1: { // variant IoFreeInput(GArg,SigU)
    IoFreeInput(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IoStatePartition*/
class Rti29IoStatePartition : public Function { 
public:
Rti29IoStatePartition(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti29IoStatePartition(pFuncDef); };
protected:
IoSystem* mP_0_0;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IoStatePartition(System)
    switch(n) { 
    case 0:     res=DoTypeCast<IoSystem>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IoStatePartition(System)
    IoStatePartition(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IoSynthesis*/
class Rti30IoSynthesis : public Function { 
public:
Rti30IoSynthesis(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti30IoSynthesis(pFuncDef); };
protected:
IoSystem* mP_0_0;
Generator* mP_0_1;
IoSystem* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IoSynthesis(GPlant,GSpec,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<IoSystem>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<IoSystem>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IoSynthesis(GPlant,GSpec,GSupervisor)
    IoSynthesis(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IoSynthesisNB*/
class Rti31IoSynthesisNB : public Function { 
public:
Rti31IoSynthesisNB(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti31IoSynthesisNB(pFuncDef); };
protected:
IoSystem* mP_0_0;
Generator* mP_0_1;
IoSystem* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IoSynthesisNB(GPlant,GSpec,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<IoSystem>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<IoSystem>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IoSynthesisNB(GPlant,GSpec,GSupervisor)
    IoSynthesisNB(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsAccessible*/
class Rti32IsAccessible : public Function { 
public:
Rti32IsAccessible(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti32IsAccessible(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Default
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Default
    *(mP_0_1->CReference()) = IsAccessible(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsCoDiagnosable*/
class Rti33IsCoDiagnosable : public Function { 
public:
Rti33IsCoDiagnosable(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti33IsCoDiagnosable(pFuncDef); };
protected:
System* mP_0_0;
Generator* mP_0_1;
EventSetVector* mP_0_2;
Boolean* mP_0_3;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsCoDiagnosable(GArg,KArg,AVArg,BRes)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSetVector>(2, mP_0_2); break; 
    case 3:     res=DoTypeCast<Boolean>(3, mP_0_3); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsCoDiagnosable(GArg,KArg,AVArg,BRes)
    *(mP_0_3->CReference()) = IsCoDiagnosable(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsCoaccessible*/
class Rti34IsCoaccessible : public Function { 
public:
Rti34IsCoaccessible(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti34IsCoaccessible(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Default
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Default
    *(mP_0_1->CReference()) = IsCoaccessible(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsComplete*/
class Rti35IsComplete : public Function { 
public:
Rti35IsComplete(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti35IsComplete(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
Generator* mP_1_0;
EventSet* mP_1_1;
Boolean* mP_1_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsComplete(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant IsComplete(G,SigmaO)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_1_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsComplete(G)
    *(mP_0_1->CReference()) = IsComplete(*mP_0_0); break; };
  case 1: { // variant IsComplete(G,SigmaO)
    *(mP_1_2->CReference()) = IsComplete(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsConditionalClosed*/
class Rti36IsConditionalClosed : public Function { 
public:
Rti36IsConditionalClosed(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti36IsConditionalClosed(pFuncDef); };
protected:
GeneratorVector* mP_0_0;
Generator* mP_0_1;
GeneratorVector* mP_0_2;
Generator* mP_0_3;
Boolean* mP_0_4;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsConditionalClosed(specVect,pk,genVect,gk)
    switch(n) { 
    case 0:     res=DoTypeCast<GeneratorVector>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<GeneratorVector>(2, mP_0_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_0_3); break; 
    case 4:     res=DoTypeCast<Boolean>(4, mP_0_4); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsConditionalClosed(specVect,pk,genVect,gk)
    *(mP_0_4->CReference()) = IsConditionalClosed(*mP_0_0 ,*mP_0_1 ,*mP_0_2 ,*mP_0_3); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsConditionalControllable*/
class Rti37IsConditionalControllable : public Function { 
public:
Rti37IsConditionalControllable(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti37IsConditionalControllable(pFuncDef); };
protected:
GeneratorVector* mP_0_0;
Generator* mP_0_1;
GeneratorVector* mP_0_2;
Generator* mP_0_3;
EventSet* mP_0_4;
Boolean* mP_0_5;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsConditionalControllable(specVect,pk,genVect,gk,ACntrl)
    switch(n) { 
    case 0:     res=DoTypeCast<GeneratorVector>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<GeneratorVector>(2, mP_0_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_0_3); break; 
    case 4:     res=DoTypeCast<EventSet>(4, mP_0_4); break; 
    case 5:     res=DoTypeCast<Boolean>(5, mP_0_5); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsConditionalControllable(specVect,pk,genVect,gk,ACntrl)
    *(mP_0_5->CReference()) = IsConditionalControllable(*mP_0_0 ,*mP_0_1 ,*mP_0_2 ,*mP_0_3 ,*mP_0_4); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsConditionalDecomposable*/
class Rti38IsConditionalDecomposable : public Function { 
public:
Rti38IsConditionalDecomposable(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti38IsConditionalDecomposable(pFuncDef); };
protected:
System* mP_0_0;
EventSetVector* mP_0_1;
EventSet* mP_0_2;
System* mP_0_3;
Boolean* mP_0_4;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsConditionalDecomposable(gen,alphVector,ek,proof)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSetVector>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_0_2); break; 
    case 3:     res=DoTypeCast<System>(3, mP_0_3); break; 
    case 4:     res=DoTypeCast<Boolean>(4, mP_0_4); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsConditionalDecomposable(gen,alphVector,ek,proof)
    *(mP_0_4->CReference()) = IsConditionalDecomposable(*mP_0_0 ,*mP_0_1 ,*mP_0_2 ,*mP_0_3); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsControllable*/
class Rti39IsControllable : public Function { 
public:
Rti39IsControllable(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti39IsControllable(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
Generator* mP_0_2;
Boolean* mP_0_3;
System* mP_1_0;
Generator* mP_1_1;
Boolean* mP_1_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsControllabel(G,Sigma,K)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    case 3:     res=DoTypeCast<Boolean>(3, mP_0_3); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant IsControllabel(G,K)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_1_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsControllabel(G,Sigma,K)
    *(mP_0_3->CReference()) = IsControllable(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant IsControllabel(G,K)
    *(mP_1_2->CReference()) = IsControllable(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsDeterministic*/
class Rti40IsDeterministic : public Function { 
public:
Rti40IsDeterministic(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti40IsDeterministic(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsDeterministic(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsDeterministic(G)
    *(mP_0_1->CReference()) = IsDeterministic(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsEmptyLanguage*/
class Rti41IsEmptyLanguage : public Function { 
public:
Rti41IsEmptyLanguage(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti41IsEmptyLanguage(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GArg) == 0
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GArg) == 0
    *(mP_0_1->CReference()) = IsEmptyLanguage(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsEventDiagnosable*/
class Rti42IsEventDiagnosable : public Function { 
public:
Rti42IsEventDiagnosable(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti42IsEventDiagnosable(pFuncDef); };
protected:
System* mP_0_0;
AttributeFailureTypeMap* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsEventDiagnosable(GArg,FMapArg,BRes)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<AttributeFailureTypeMap>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsEventDiagnosable(GArg,FMapArg,BRes)
    *(mP_0_2->CReference()) = IsEventDiagnosable(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsHioConstraintForm*/
class Rti43IsHioConstraintForm : public Function { 
public:
Rti43IsHioConstraintForm(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti43IsHioConstraintForm(pFuncDef); };
protected:
HioConstraint* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsHioConstraintForm(GArg,BRes)
    switch(n) { 
    case 0:     res=DoTypeCast<HioConstraint>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsHioConstraintForm(GArg,BRes)
    *(mP_0_1->CReference()) = IsHioConstraintForm(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsHioControllerForm*/
class Rti44IsHioControllerForm : public Function { 
public:
Rti44IsHioControllerForm(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti44IsHioControllerForm(pFuncDef); };
protected:
HioController* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsHioControllerForm(GArg,BRes)
    switch(n) { 
    case 0:     res=DoTypeCast<HioController>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsHioControllerForm(GArg,BRes)
    *(mP_0_1->CReference()) = IsHioControllerForm(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsHioEnvironmentForm*/
class Rti45IsHioEnvironmentForm : public Function { 
public:
Rti45IsHioEnvironmentForm(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti45IsHioEnvironmentForm(pFuncDef); };
protected:
HioEnvironment* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsHioEnvironmentForm(GArg,BRes)
    switch(n) { 
    case 0:     res=DoTypeCast<HioEnvironment>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsHioEnvironmentForm(GArg,BRes)
    *(mP_0_1->CReference()) = IsHioEnvironmentForm(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsHioPlantForm*/
class Rti46IsHioPlantForm : public Function { 
public:
Rti46IsHioPlantForm(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti46IsHioPlantForm(pFuncDef); };
protected:
HioPlant* mP_0_0;
String* mP_0_1;
Boolean* mP_0_2;
HioPlant* mP_1_0;
Boolean* mP_1_1;
HioPlant* mP_2_0;
StateSet* mP_2_1;
StateSet* mP_2_2;
StateSet* mP_2_3;
EventSet* mP_2_4;
TransSet* mP_2_5;
StateSet* mP_2_6;
String* mP_2_7;
Boolean* mP_2_8;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsHioPlantForm(GArg,ErrStr,BRes)
    switch(n) { 
    case 0:     res=DoTypeCast<HioPlant>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<String>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant IsHioPlantForm(GArg,BRes)
    switch(n) { 
    case 0:     res=DoTypeCast<HioPlant>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 2: { // variant IsHioPlantForm(GArg,Qxx,ErrStr,BRes)
    switch(n) { 
    case 0:     res=DoTypeCast<HioPlant>(0, mP_2_0); break; 
    case 1:     res=DoTypeCast<StateSet>(1, mP_2_1); break; 
    case 2:     res=DoTypeCast<StateSet>(2, mP_2_2); break; 
    case 3:     res=DoTypeCast<StateSet>(3, mP_2_3); break; 
    case 4:     res=DoTypeCast<EventSet>(4, mP_2_4); break; 
    case 5:     res=DoTypeCast<TransSet>(5, mP_2_5); break; 
    case 6:     res=DoTypeCast<StateSet>(6, mP_2_6); break; 
    case 7:     res=DoTypeCast<String>(7, mP_2_7); break; 
    case 8:     res=DoTypeCast<Boolean>(8, mP_2_8); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsHioPlantForm(GArg,ErrStr,BRes)
    *(mP_0_2->CReference()) = IsHioPlantForm(*mP_0_0 ,*(mP_0_1->CReference())); break; };
  case 1: { // variant IsHioPlantForm(GArg,BRes)
    *(mP_1_1->CReference()) = IsHioPlantForm(*mP_1_0); break; };
  case 2: { // variant IsHioPlantForm(GArg,Qxx,ErrStr,BRes)
    *(mP_2_8->CReference()) = IsHioPlantForm(*mP_2_0 ,*mP_2_1 ,*mP_2_2 ,*mP_2_3 ,*mP_2_4 ,*mP_2_5 ,*mP_2_6 ,*(mP_2_7->CReference())); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsIndicatorEventDiagnosable*/
class Rti47IsIndicatorEventDiagnosable : public Function { 
public:
Rti47IsIndicatorEventDiagnosable(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti47IsIndicatorEventDiagnosable(pFuncDef); };
protected:
System* mP_0_0;
AttributeFailureTypeMap* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsIndicatorEventDiagnosable(GArg,FMapArg,BRes)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<AttributeFailureTypeMap>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsIndicatorEventDiagnosable(GArg,FMapArg,BRes)
    *(mP_0_2->CReference()) = IsIndicatorEventDiagnosable(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsInputLocallyFree*/
class Rti48IsInputLocallyFree : public Function { 
public:
Rti48IsInputLocallyFree(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti48IsInputLocallyFree(pFuncDef); };
protected:
IoSystem* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsInputLocallyFree(GArg,BRes)
    switch(n) { 
    case 0:     res=DoTypeCast<IoSystem>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsInputLocallyFree(GArg,BRes)
    *(mP_0_1->CReference()) = IsInputLocallyFree(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsInputOmegaFree*/
class Rti49IsInputOmegaFree : public Function { 
public:
Rti49IsInputOmegaFree(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti49IsInputOmegaFree(pFuncDef); };
protected:
IoSystem* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsInputOmegaFree(GArg,BRes)
    switch(n) { 
    case 0:     res=DoTypeCast<IoSystem>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsInputOmegaFree(GArg,BRes)
    *(mP_0_1->CReference()) = IsInputOmegaFree(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsIoSystem*/
class Rti50IsIoSystem : public Function { 
public:
Rti50IsIoSystem(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti50IsIoSystem(pFuncDef); };
protected:
IoSystem* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsIoSystem(GArg,BRes)
    switch(n) { 
    case 0:     res=DoTypeCast<IoSystem>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsIoSystem(GArg,BRes)
    *(mP_0_1->CReference()) = IsIoSystem(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsLanguageDiagnosable*/
class Rti51IsLanguageDiagnosable : public Function { 
public:
Rti51IsLanguageDiagnosable(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti51IsLanguageDiagnosable(pFuncDef); };
protected:
System* mP_0_0;
Generator* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsLanguageDiagnosable(GArg,EArg,OArgBRes)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsLanguageDiagnosable(GArg,EArg,OArgBRes)
    *(mP_0_2->CReference()) = IsLanguageDiagnosable(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsLCC*/
class Rti52IsLCC : public Function { 
public:
Rti52IsLCC(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti52IsLCC(pFuncDef); };
protected:
System* mP_0_0;
EventSet* mP_0_1;
Boolean* mP_0_2;
Generator* mP_1_0;
EventSet* mP_1_1;
EventSet* mP_1_2;
Boolean* mP_1_3;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsLcc(GArg,Sigma_h,Res)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant IsLcc(GArg,Sigma_c,Sigma_h,Res)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_1_2); break; 
    case 3:     res=DoTypeCast<Boolean>(3, mP_1_3); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsLcc(GArg,Sigma_h,Res)
    *(mP_0_2->CReference()) = IsLCC(*mP_0_0 ,*mP_0_1); break; };
  case 1: { // variant IsLcc(GArg,Sigma_c,Sigma_h,Res)
    *(mP_1_3->CReference()) = IsLCC(*mP_1_0 ,*mP_1_1 ,*mP_1_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsLoopPreservingObserver*/
class Rti53IsLoopPreservingObserver : public Function { 
public:
Rti53IsLoopPreservingObserver(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti53IsLoopPreservingObserver(pFuncDef); };
protected:
System* mP_0_0;
EventSet* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsLoopPreservingObserver(GArg,AArg,OArgBRes)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsLoopPreservingObserver(GArg,AArg,OArgBRes)
    *(mP_0_2->CReference()) = IsLoopPreservingObserver(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsModularDiagnosable*/
class Rti54IsModularDiagnosable : public Function { 
public:
Rti54IsModularDiagnosable(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti54IsModularDiagnosable(pFuncDef); };
protected:
SystemVector* mP_0_0;
GeneratorVector* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsModularDiagnosable(GVArg,KVArg,BRes)
    switch(n) { 
    case 0:     res=DoTypeCast<SystemVector>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<GeneratorVector>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsModularDiagnosable(GVArg,KVArg,BRes)
    *(mP_0_2->CReference()) = IsModularDiagnosable(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsMSA*/
class Rti55IsMSA : public Function { 
public:
Rti55IsMSA(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti55IsMSA(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsMsaObs(GArg,Sigma_h,Res)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsMsaObs(GArg,Sigma_h,Res)
    *(mP_0_2->CReference()) = IsMSA(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsMtcObs*/
class Rti56IsMtcObs : public Function { 
public:
Rti56IsMtcObs(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti56IsMtcObs(pFuncDef); };
protected:
MtcSystem* mP_0_0;
EventSet* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsMtcObserver(Plant,SigmaHigh,Res)
    switch(n) { 
    case 0:     res=DoTypeCast<MtcSystem>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsMtcObserver(Plant,SigmaHigh,Res)
    *(mP_0_2->CReference()) = IsMtcObs(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsMutuallyControllable*/
class Rti57IsMutuallyControllable : public Function { 
public:
Rti57IsMutuallyControllable(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti57IsMutuallyControllable(pFuncDef); };
protected:
System* mP_0_0;
System* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsMutuallyControllable(Sys1,Sys2)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<System>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsMutuallyControllable(Sys1,Sys2)
    *(mP_0_2->CReference()) = IsMutuallyControllable(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsObs*/
class Rti58IsObs : public Function { 
public:
Rti58IsObs(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti58IsObs(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsObs(GArg,Sigma_h,Res)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsObs(GArg,Sigma_h,Res)
    *(mP_0_2->CReference()) = IsObs(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsNonblocking*/
class Rti59IsNonblocking : public Function { 
public:
Rti59IsNonblocking(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti59IsNonblocking(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
Generator* mP_1_0;
Generator* mP_1_1;
Boolean* mP_1_2;
GeneratorVector* mP_2_0;
Boolean* mP_2_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsNonblocking(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant IsNonblocking(G1,G2)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_1_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 2: { // variant IsNonblocking(G1,G2 ... Gn)
    switch(n) { 
    case 0:     res=DoTypeCast<GeneratorVector>(0, mP_2_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_2_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsNonblocking(G)
    *(mP_0_1->CReference()) = IsNonblocking(*mP_0_0); break; };
  case 1: { // variant IsNonblocking(G1,G2)
    *(mP_1_2->CReference()) = IsNonblocking(*mP_1_0 ,*mP_1_1); break; };
  case 2: { // variant IsNonblocking(G1,G2 ... Gn)
    *(mP_2_1->CReference()) = IsNonblocking(*mP_2_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsNormal*/
class Rti60IsNormal : public Function { 
public:
Rti60IsNormal(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti60IsNormal(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
Generator* mP_0_2;
Boolean* mP_0_3;
System* mP_1_0;
Generator* mP_1_1;
Boolean* mP_1_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsNormal(L,Sigma_o,K)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    case 3:     res=DoTypeCast<Boolean>(3, mP_0_3); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant IsNormal(G,C)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_1_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsNormal(L,Sigma_o,K)
    *(mP_0_3->CReference()) = IsNormal(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant IsNormal(G,C)
    *(mP_1_2->CReference()) = IsNormal(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsOmegaClosed*/
class Rti61IsOmegaClosed : public Function { 
public:
Rti61IsOmegaClosed(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti61IsOmegaClosed(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsOmegaClosed(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsOmegaClosed(G)
    *(mP_0_1->CReference()) = IsOmegaClosed(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsOmegaControllable*/
class Rti62IsOmegaControllable : public Function { 
public:
Rti62IsOmegaControllable(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti62IsOmegaControllable(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
Generator* mP_0_2;
Boolean* mP_0_3;
System* mP_1_0;
Generator* mP_1_1;
Boolean* mP_1_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsOmegaControllabel(G,Sigma,K)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    case 3:     res=DoTypeCast<Boolean>(3, mP_0_3); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant IsOmegaControllabel(G,K)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_1_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsOmegaControllabel(G,Sigma,K)
    *(mP_0_3->CReference()) = IsOmegaControllable(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant IsOmegaControllabel(G,K)
    *(mP_1_2->CReference()) = IsOmegaControllable(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsOmegaTrim*/
class Rti63IsOmegaTrim : public Function { 
public:
Rti63IsOmegaTrim(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti63IsOmegaTrim(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Default
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Default
    *(mP_0_1->CReference()) = IsOmegaTrim(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsOCC*/
class Rti64IsOCC : public Function { 
public:
Rti64IsOCC(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti64IsOCC(pFuncDef); };
protected:
System* mP_0_0;
EventSet* mP_0_1;
Boolean* mP_0_2;
Generator* mP_1_0;
EventSet* mP_1_1;
EventSet* mP_1_2;
Boolean* mP_1_3;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsOcc(GArg,Sigma_h,Res)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant IsOcc(GArg,Sigma_c,Sigma_h,Res)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_1_2); break; 
    case 3:     res=DoTypeCast<Boolean>(3, mP_1_3); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsOcc(GArg,Sigma_h,Res)
    *(mP_0_2->CReference()) = IsOCC(*mP_0_0 ,*mP_0_1); break; };
  case 1: { // variant IsOcc(GArg,Sigma_c,Sigma_h,Res)
    *(mP_1_3->CReference()) = IsOCC(*mP_1_0 ,*mP_1_1 ,*mP_1_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsPrefixClosed*/
class Rti65IsPrefixClosed : public Function { 
public:
Rti65IsPrefixClosed(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti65IsPrefixClosed(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsPrefixClosed(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsPrefixClosed(G)
    *(mP_0_1->CReference()) = IsPrefixClosed(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsRelativelyMarked*/
class Rti66IsRelativelyMarked : public Function { 
public:
Rti66IsRelativelyMarked(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti66IsRelativelyMarked(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsRelativelyMarked(GPlant,GCand)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsRelativelyMarked(GPlant,GCand)
    *(mP_0_2->CReference()) = IsRelativelyMarked(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsRelativelyOmegaClosed*/
class Rti67IsRelativelyOmegaClosed : public Function { 
public:
Rti67IsRelativelyOmegaClosed(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti67IsRelativelyOmegaClosed(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsRelativelyOmegaClosed(GPlant,GCand)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsRelativelyOmegaClosed(GPlant,GCand)
    *(mP_0_2->CReference()) = IsRelativelyOmegaClosed(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsRelativelyPrefixClosed*/
class Rti68IsRelativelyPrefixClosed : public Function { 
public:
Rti68IsRelativelyPrefixClosed(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti68IsRelativelyPrefixClosed(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsRelativelyPrefixClosed(GPlant,GCand)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsRelativelyPrefixClosed(GPlant,GCand)
    *(mP_0_2->CReference()) = IsRelativelyPrefixClosed(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsStdSynthesisConsistent*/
class Rti69IsStdSynthesisConsistent : public Function { 
public:
Rti69IsStdSynthesisConsistent(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti69IsStdSynthesisConsistent(pFuncDef); };
protected:
System* mP_0_0;
Generator* mP_0_1;
Boolean* mP_0_2;
Generator* mP_1_0;
EventSet* mP_1_1;
Generator* mP_1_2;
Boolean* mP_1_3;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant IsStdSynCons(GPlant,GPlant0,BRes)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant IsStdSynCons(GPlant,ACtrl,GPlant0,BRes)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_1_2); break; 
    case 3:     res=DoTypeCast<Boolean>(3, mP_1_3); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant IsStdSynCons(GPlant,GPlant0,BRes)
    *(mP_0_2->CReference()) = IsStdSynthesisConsistent(*mP_0_0 ,*mP_0_1); break; };
  case 1: { // variant IsStdSynCons(GPlant,ACtrl,GPlant0,BRes)
    *(mP_1_3->CReference()) = IsStdSynthesisConsistent(*mP_1_0 ,*mP_1_1 ,*mP_1_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsStronglyCoaccessible*/
class Rti70IsStronglyCoaccessible : public Function { 
public:
Rti70IsStronglyCoaccessible(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti70IsStronglyCoaccessible(pFuncDef); };
protected:
MtcSystem* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Default
    switch(n) { 
    case 0:     res=DoTypeCast<MtcSystem>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Default
    *(mP_0_1->CReference()) = IsStronglyCoaccessible(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsStronglyTrim*/
class Rti71IsStronglyTrim : public Function { 
public:
Rti71IsStronglyTrim(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti71IsStronglyTrim(pFuncDef); };
protected:
MtcSystem* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Default
    switch(n) { 
    case 0:     res=DoTypeCast<MtcSystem>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Default
    *(mP_0_1->CReference()) = IsStronglyTrim(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function IsTrim*/
class Rti72IsTrim : public Function { 
public:
Rti72IsTrim(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti72IsTrim(pFuncDef); };
protected:
Generator* mP_0_0;
Boolean* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Default
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Boolean>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Default
    *(mP_0_1->CReference()) = IsTrim(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function KleeneClosure*/
class Rti73KleeneClosure : public Function { 
public:
Rti73KleeneClosure(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti73KleeneClosure(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G) := Lm(G)*
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Lm(GRes) := Lm(GArg)*
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G) := Lm(G)*
    KleeneClosure(*mP_0_0); break; };
  case 1: { // variant Lm(GRes) := Lm(GArg)*
    KleeneClosure(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageComplement*/
class Rti74LanguageComplement : public Function { 
public:
Rti74LanguageComplement(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti74LanguageComplement(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
Generator* mP_2_0;
EventSet* mP_2_1;
Generator* mP_2_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GPar) := -Lm(GPar)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Lm(GRes) = -Lm(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 2: { // variant Lm(GRes) = Sigma^* - Lm(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_2_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_2_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_2_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GPar) := -Lm(GPar)
    LanguageComplement(*mP_0_0); break; };
  case 1: { // variant Lm(GRes) = -Lm(GArg)
    LanguageComplement(*mP_1_0 ,*mP_1_1); break; };
  case 2: { // variant Lm(GRes) = Sigma^* - Lm(GArg)
    LanguageComplement(*mP_2_0 ,*mP_2_1 ,*mP_2_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageConcatenate*/
class Rti75LanguageConcatenate : public Function { 
public:
Rti75LanguageConcatenate(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti75LanguageConcatenate(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) Lm(G2)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) Lm(G2)
    LanguageConcatenate(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageDiagnoser*/
class Rti76LanguageDiagnoser : public Function { 
public:
Rti76LanguageDiagnoser(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti76LanguageDiagnoser(pFuncDef); };
protected:
System* mP_0_0;
Generator* mP_0_1;
Diagnoser* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant LanguageDiagnoser(Gen,Spec,Diagnoser)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Diagnoser>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant LanguageDiagnoser(Gen,Spec,Diagnoser)
    LanguageDiagnoser(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageDifference*/
class Rti77LanguageDifference : public Function { 
public:
Rti77LanguageDifference(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti77LanguageDifference(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) - Lm(G2)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) - Lm(G2)
    LanguageDifference(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageDisjoint*/
class Rti78LanguageDisjoint : public Function { 
public:
Rti78LanguageDisjoint(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti78LanguageDisjoint(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G1) ^ Lm(G2) == 0
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G1) ^ Lm(G2) == 0
    *(mP_0_2->CReference()) = LanguageDisjoint(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageEquality*/
class Rti79LanguageEquality : public Function { 
public:
Rti79LanguageEquality(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti79LanguageEquality(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G1) == Lm(G2)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G1) == Lm(G2)
    *(mP_0_2->CReference()) = LanguageEquality(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageInclusion*/
class Rti80LanguageInclusion : public Function { 
public:
Rti80LanguageInclusion(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti80LanguageInclusion(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G1) <= Lm(G2)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(G1) <= Lm(G2)
    *(mP_0_2->CReference()) = LanguageInclusion(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageIntersection*/
class Rti81LanguageIntersection : public Function { 
public:
Rti81LanguageIntersection(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti81LanguageIntersection(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
GeneratorVector* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) v Lm(G2)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Lm(GRes) = ^_i(G_i)
    switch(n) { 
    case 0:     res=DoTypeCast<GeneratorVector>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) v Lm(G2)
    LanguageIntersection(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant Lm(GRes) = ^_i(G_i)
    LanguageIntersection(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LanguageUnion*/
class Rti82LanguageUnion : public Function { 
public:
Rti82LanguageUnion(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti82LanguageUnion(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
GeneratorVector* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) v Lm(G2)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Lm(GRes) = v_i(G_i)
    switch(n) { 
    case 0:     res=DoTypeCast<GeneratorVector>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Lm(GRes) = Lm(G1) v Lm(G2)
    LanguageUnion(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant Lm(GRes) = v_i(G_i)
    LanguageUnion(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LocalObservationConsistency*/
class Rti83LocalObservationConsistency : public Function { 
public:
Rti83LocalObservationConsistency(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti83LocalObservationConsistency(pFuncDef); };
protected:
System* mP_0_0;
System* mP_0_1;
EventSet* mP_0_2;
EventSet* mP_0_3;
Boolean* mP_0_4;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant LocalObservationConsistency(G,K,Sigma,E)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<System>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_0_2); break; 
    case 3:     res=DoTypeCast<EventSet>(3, mP_0_3); break; 
    case 4:     res=DoTypeCast<Boolean>(4, mP_0_4); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant LocalObservationConsistency(G,K,Sigma,E)
    *(mP_0_4->CReference()) = LocalObservationConsistency(*mP_0_0 ,*mP_0_1 ,*mP_0_2 ,*mP_0_3); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function LoopPreservingObserver*/
class Rti84LoopPreservingObserver : public Function { 
public:
Rti84LoopPreservingObserver(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti84LoopPreservingObserver(pFuncDef); };
protected:
System* mP_0_0;
EventSet* mP_0_1;
EventSet* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant LoopPreservingObserver(GArg,IArg,AArg)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant LoopPreservingObserver(GArg,IArg,AArg)
    LoopPreservingObserver(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function MarkAllStates*/
class Rti85MarkAllStates : public Function { 
public:
Rti85MarkAllStates(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti85MarkAllStates(pFuncDef); };
protected:
Generator* mP_0_0;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Mark(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Mark(G)
    MarkAllStates(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function ModularDiagnoser*/
class Rti86ModularDiagnoser : public Function { 
public:
Rti86ModularDiagnoser(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti86ModularDiagnoser(pFuncDef); };
protected:
SystemVector* mP_0_0;
GeneratorVector* mP_0_1;
GeneratorVector* mP_0_2;
Boolean* mP_0_3;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant ModularDiagnoser(GVArg,KVArg,DVArg,BRes)
    switch(n) { 
    case 0:     res=DoTypeCast<SystemVector>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<GeneratorVector>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<GeneratorVector>(2, mP_0_2); break; 
    case 3:     res=DoTypeCast<Boolean>(3, mP_0_3); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant ModularDiagnoser(GVArg,KVArg,DVArg,BRes)
    *(mP_0_3->CReference()) = ModularDiagnoser(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function calcMSAObserver*/
class Rti87calcMSAObserver : public Function { 
public:
Rti87calcMSAObserver(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti87calcMSAObserver(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
Generator* mP_1_0;
EventSet* mP_1_1;
Integer* mP_1_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant MsaObs(GArg,Sigma_h)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant MsaObs(GArg,Sigma_h,#Q)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Integer>(2, mP_1_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant MsaObs(GArg,Sigma_h)
    calcMSAObserver(*mP_0_0 ,*mP_0_1); break; };
  case 1: { // variant MsaObs(GArg,Sigma_h,#Q)
    *(mP_1_2->CReference()) = calcMSAObserver(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function calcMSAObserverLCC*/
class Rti88calcMSAObserverLCC : public Function { 
public:
Rti88calcMSAObserverLCC(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti88calcMSAObserverLCC(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
EventSet* mP_0_2;
Generator* mP_1_0;
EventSet* mP_1_1;
EventSet* mP_1_2;
Integer* mP_1_3;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant MsaObsLcc(Plant,Sigma_c,Sigma_h)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant MsaObsLcc(Plant,Sigma_c,Sigma_h,#Q)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_1_2); break; 
    case 3:     res=DoTypeCast<Integer>(3, mP_1_3); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant MsaObsLcc(Plant,Sigma_c,Sigma_h)
    calcMSAObserverLCC(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant MsaObsLcc(Plant,Sigma_c,Sigma_h,#Q)
    *(mP_1_3->CReference()) = calcMSAObserverLCC(*mP_1_0 ,*mP_1_1 ,*mP_1_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function mtcDeterministic*/
class Rti89mtcDeterministic : public Function { 
public:
Rti89mtcDeterministic(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti89mtcDeterministic(pFuncDef); };
protected:
MtcSystem* mP_0_0;
MtcSystem* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant MtcDeterministic(G,GRes)
    switch(n) { 
    case 0:     res=DoTypeCast<MtcSystem>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<MtcSystem>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant MtcDeterministic(G,GRes)
    mtcDeterministic(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function mtcInvProject*/
class Rti90mtcInvProject : public Function { 
public:
Rti90mtcInvProject(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti90mtcInvProject(pFuncDef); };
protected:
MtcSystem* mP_0_0;
EventSet* mP_0_1;
MtcSystem* mP_1_0;
EventSet* mP_1_1;
MtcSystem* mP_1_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant MtcInvProject(G0,Sigma)
    switch(n) { 
    case 0:     res=DoTypeCast<MtcSystem>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant InvProject(G0,Sigma,GRes)
    switch(n) { 
    case 0:     res=DoTypeCast<MtcSystem>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<MtcSystem>(2, mP_1_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant MtcInvProject(G0,Sigma)
    mtcInvProject(*mP_0_0 ,*mP_0_1); break; };
  case 1: { // variant InvProject(G0,Sigma,GRes)
    mtcInvProject(*mP_1_0 ,*mP_1_1 ,*mP_1_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function calcNaturalObserver*/
class Rti91calcNaturalObserver : public Function { 
public:
Rti91calcNaturalObserver(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti91calcNaturalObserver(pFuncDef); };
protected:
MtcSystem* mP_0_0;
EventSet* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant MtcNaturalObserver(GPlant,SigmaH)
    switch(n) { 
    case 0:     res=DoTypeCast<MtcSystem>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant MtcNaturalObserver(GPlant,SigmaH)
    calcNaturalObserver(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function mtcParallel*/
class Rti92mtcParallel : public Function { 
public:
Rti92mtcParallel(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti92mtcParallel(pFuncDef); };
protected:
MtcSystem* mP_0_0;
MtcSystem* mP_0_1;
MtcSystem* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 || G2
    switch(n) { 
    case 0:     res=DoTypeCast<MtcSystem>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<MtcSystem>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<MtcSystem>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 || G2
    mtcParallel(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function mtcProject*/
class Rti93mtcProject : public Function { 
public:
Rti93mtcProject(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti93mtcProject(pFuncDef); };
protected:
MtcSystem* mP_0_0;
EventSet* mP_0_1;
MtcSystem* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant MtcProject(G,Sigmal0,Res)
    switch(n) { 
    case 0:     res=DoTypeCast<MtcSystem>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<MtcSystem>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant MtcProject(G,Sigmal0,Res)
    mtcProject(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function mtcProjectNonDet*/
class Rti94mtcProjectNonDet : public Function { 
public:
Rti94mtcProjectNonDet(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti94mtcProjectNonDet(pFuncDef); };
protected:
MtcSystem* mP_0_0;
EventSet* mP_0_1;
MtcSystem* mP_0_2;
MtcSystem* mP_1_0;
EventSet* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant MtcProjectNonDet(G,Sigmal0,Res)
    switch(n) { 
    case 0:     res=DoTypeCast<MtcSystem>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<MtcSystem>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant MtcProjectNonDet(G,Sigmal0)
    switch(n) { 
    case 0:     res=DoTypeCast<MtcSystem>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant MtcProjectNonDet(G,Sigmal0,Res)
    mtcProjectNonDet(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant MtcProjectNonDet(G,Sigmal0)
    mtcProjectNonDet(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function mtcStateMin*/
class Rti95mtcStateMin : public Function { 
public:
Rti95mtcStateMin(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti95mtcStateMin(pFuncDef); };
protected:
MtcSystem* mP_0_0;
MtcSystem* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant MtcStateMin(G,GRes)
    switch(n) { 
    case 0:     res=DoTypeCast<MtcSystem>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<MtcSystem>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant MtcStateMin(G,GRes)
    mtcStateMin(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function mtcSupConClosed*/
class Rti96mtcSupConClosed : public Function { 
public:
Rti96mtcSupConClosed(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti96mtcSupConClosed(pFuncDef); };
protected:
MtcSystem* mP_0_0;
MtcSystem* mP_0_1;
MtcSystem* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant MtcSupConClosed(GPlant,GSpec,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<MtcSystem>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<MtcSystem>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<MtcSystem>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant MtcSupConClosed(GPlant,GSpec,GSupervisor)
    mtcSupConClosed(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function mtcSupConNB*/
class Rti97mtcSupConNB : public Function { 
public:
Rti97mtcSupConNB(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti97mtcSupConNB(pFuncDef); };
protected:
MtcSystem* mP_0_0;
MtcSystem* mP_0_1;
MtcSystem* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant MtcSupConNB(GPlant,GSpec,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<MtcSystem>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<MtcSystem>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<MtcSystem>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant MtcSupConNB(GPlant,GSpec,GSupervisor)
    mtcSupConNB(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function calcNaturalObserver*/
class Rti98calcNaturalObserver : public Function { 
public:
Rti98calcNaturalObserver(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti98calcNaturalObserver(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
Generator* mP_1_0;
EventSet* mP_1_1;
Integer* mP_1_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant NatObs(GArg,Sigma_h)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant NatObs(GArg,Sigma_h,#Q)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Integer>(2, mP_1_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant NatObs(GArg,Sigma_h)
    calcNaturalObserver(*mP_0_0 ,*mP_0_1); break; };
  case 1: { // variant NatObs(GArg,Sigma_h,#Q)
    *(mP_1_2->CReference()) = calcNaturalObserver(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function calcNaturalObserverLCC*/
class Rti99calcNaturalObserverLCC : public Function { 
public:
Rti99calcNaturalObserverLCC(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti99calcNaturalObserverLCC(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
EventSet* mP_0_2;
Generator* mP_1_0;
EventSet* mP_1_1;
EventSet* mP_1_2;
Integer* mP_1_3;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant NatObsLcc(Plant,Sigma_c,Sigma_h)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant NatObsLcc(Plant,Sigma_c,Sigma_h,#Q)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_1_2); break; 
    case 3:     res=DoTypeCast<Integer>(3, mP_1_3); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant NatObsLcc(Plant,Sigma_c,Sigma_h)
    calcNaturalObserverLCC(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant NatObsLcc(Plant,Sigma_c,Sigma_h,#Q)
    *(mP_1_3->CReference()) = calcNaturalObserverLCC(*mP_1_0 ,*mP_1_1 ,*mP_1_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function calcAbstAlphObs*/
class Rti100calcAbstAlphObs : public Function { 
public:
Rti100calcAbstAlphObs(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti100calcAbstAlphObs(pFuncDef); };
protected:
System* mP_0_0;
EventSet* mP_0_1;
EventSet* mP_0_2;
EventRelabelMap* mP_0_3;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant CalcObs(Plant,SigmaHigh,SigmaHighNew,RelabelMap)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_0_2); break; 
    case 3:     res=DoTypeCast<EventRelabelMap>(3, mP_0_3); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant CalcObs(Plant,SigmaHigh,SigmaHighNew,RelabelMap)
    calcAbstAlphObs(*mP_0_0 ,*mP_0_1 ,*mP_0_2 ,*mP_0_3); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function OmegaClosure*/
class Rti101OmegaClosure : public Function { 
public:
Rti101OmegaClosure(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti101OmegaClosure(pFuncDef); };
protected:
Generator* mP_0_0;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant OmegaClosure(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant OmegaClosure(GArg)
    OmegaClosure(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function OmegaConNB*/
class Rti102OmegaConNB : public Function { 
public:
Rti102OmegaConNB(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti102OmegaConNB(pFuncDef); };
protected:
System* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
Generator* mP_1_0;
EventSet* mP_1_1;
Generator* mP_1_2;
Generator* mP_1_3;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant OmegaConNB(GPlant,GSpec,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant OmegaConNB(GPlant,AContr,GSpec,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_1_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_1_3); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant OmegaConNB(GPlant,GSpec,GSupervisor)
    OmegaConNB(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant OmegaConNB(GPlant,AContr,GSpec,GSupervisor)
    OmegaConNB(*mP_1_0 ,*mP_1_1 ,*mP_1_2 ,*mP_1_3); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function OmegaConNormNB*/
class Rti103OmegaConNormNB : public Function { 
public:
Rti103OmegaConNormNB(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti103OmegaConNormNB(pFuncDef); };
protected:
System* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
Generator* mP_1_0;
EventSet* mP_1_1;
EventSet* mP_1_2;
Generator* mP_1_3;
Generator* mP_1_4;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant OmegaConNormNB(GPlant,GSpec,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant OmegaConNormNB(GPlant,AContr,GSpec,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_1_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_1_3); break; 
    case 4:     res=DoTypeCast<Generator>(4, mP_1_4); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant OmegaConNormNB(GPlant,GSpec,GSupervisor)
    OmegaConNormNB(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant OmegaConNormNB(GPlant,AContr,GSpec,GSupervisor)
    OmegaConNormNB(*mP_1_0 ,*mP_1_1 ,*mP_1_2 ,*mP_1_3 ,*mP_1_4); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function aOmegaParallel*/
class Rti104aOmegaParallel : public Function { 
public:
Rti104aOmegaParallel(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti104aOmegaParallel(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 || G2
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 || G2
    aOmegaParallel(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function aOmegaProduct*/
class Rti105aOmegaProduct : public Function { 
public:
Rti105aOmegaProduct(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti105aOmegaProduct(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 xx G2
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 xx G2
    aOmegaProduct(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function OmegaSupConNB*/
class Rti106OmegaSupConNB : public Function { 
public:
Rti106OmegaSupConNB(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti106OmegaSupConNB(pFuncDef); };
protected:
System* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
Generator* mP_1_0;
EventSet* mP_1_1;
Generator* mP_1_2;
Generator* mP_1_3;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant OmegaSupConNB(GPlant,GSpec,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant OmegaSupConNB(GPlant,AContr,GSpec,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_1_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_1_3); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant OmegaSupConNB(GPlant,GSpec,GSupervisor)
    OmegaSupConNB(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant OmegaSupConNB(GPlant,AContr,GSpec,GSupervisor)
    OmegaSupConNB(*mP_1_0 ,*mP_1_1 ,*mP_1_2 ,*mP_1_3); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function OmegaSupConNormNB*/
class Rti107OmegaSupConNormNB : public Function { 
public:
Rti107OmegaSupConNormNB(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti107OmegaSupConNormNB(pFuncDef); };
protected:
System* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
Generator* mP_1_0;
EventSet* mP_1_1;
EventSet* mP_1_2;
Generator* mP_1_3;
Generator* mP_1_4;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant OmegaSupConNormNB(GPlant,GSpec,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant OmegaSupConNormNB(GPlant,AContr,AObs,GSpec,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_1_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_1_3); break; 
    case 4:     res=DoTypeCast<Generator>(4, mP_1_4); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant OmegaSupConNormNB(GPlant,GSpec,GSupervisor)
    OmegaSupConNormNB(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant OmegaSupConNormNB(GPlant,AContr,AObs,GSpec,GSupervisor)
    OmegaSupConNormNB(*mP_1_0 ,*mP_1_1 ,*mP_1_2 ,*mP_1_3 ,*mP_1_4); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function OmegaTrim*/
class Rti108OmegaTrim : public Function { 
public:
Rti108OmegaTrim(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti108OmegaTrim(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant G:=OmegaTrim(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant GRes=OmegaTrim(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant G:=OmegaTrim(G)
    OmegaTrim(*mP_0_0); break; };
  case 1: { // variant GRes=OmegaTrim(GArg)
    OmegaTrim(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function OptimalColorSet*/
class Rti109OptimalColorSet : public Function { 
public:
Rti109OptimalColorSet(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti109OptimalColorSet(pFuncDef); };
protected:
MtcSystem* mP_0_0;
ColorSet* mP_0_1;
EventSet* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant OptimalColorSet(GPlant,Colors,SigmaH)
    switch(n) { 
    case 0:     res=DoTypeCast<MtcSystem>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<ColorSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant OptimalColorSet(GPlant,Colors,SigmaH)
    OptimalColorSet(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function aParallel*/
class Rti110aParallel : public Function { 
public:
Rti110aParallel(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti110aParallel(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
GeneratorVector* mP_1_0;
Generator* mP_1_1;
Generator* mP_2_0;
Generator* mP_2_1;
ProductCompositionMap* mP_2_2;
Generator* mP_2_3;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 || G2
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant GRes = || G_i
    switch(n) { 
    case 0:     res=DoTypeCast<GeneratorVector>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 2: { // variant Parallel with ComMap
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_2_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_2_1); break; 
    case 2:     res=DoTypeCast<ProductCompositionMap>(2, mP_2_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_2_3); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 || G2
    aParallel(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant GRes = || G_i
    aParallel(*mP_1_0 ,*mP_1_1); break; };
  case 2: { // variant Parallel with ComMap
    aParallel(*mP_2_0 ,*mP_2_1 ,*mP_2_2 ,*mP_2_3); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function PrefixClosure*/
class Rti111PrefixClosure : public Function { 
public:
Rti111PrefixClosure(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti111PrefixClosure(pFuncDef); };
protected:
Generator* mP_0_0;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant PrefixClosure(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant PrefixClosure(GArg)
    PrefixClosure(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function aProduct*/
class Rti112aProduct : public Function { 
public:
Rti112aProduct(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti112aProduct(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
Generator* mP_1_0;
Generator* mP_1_1;
ProductCompositionMap* mP_1_2;
Generator* mP_1_3;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 x G2
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant Product with ComMap
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<ProductCompositionMap>(2, mP_1_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_1_3); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant GRes = G1 x G2
    aProduct(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant Product with ComMap
    aProduct(*mP_1_0 ,*mP_1_1 ,*mP_1_2 ,*mP_1_3); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function aProject*/
class Rti113aProject : public Function { 
public:
Rti113aProject(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti113aProject(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
Generator* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Project(G,Sigmal0,Res)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Project(G,Sigmal0,Res)
    aProject(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function PushdownAccessible*/
class Rti114PushdownAccessible : public Function { 
public:
Rti114PushdownAccessible(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti114PushdownAccessible(pFuncDef); };
protected:
PushdownGenerator* mP_0_0;
PushdownGenerator* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Default
    switch(n) { 
    case 0:     res=DoTypeCast<PushdownGenerator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<PushdownGenerator>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Default
    PushdownAccessible(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function PushdownBlockfree*/
class Rti115PushdownBlockfree : public Function { 
public:
Rti115PushdownBlockfree(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti115PushdownBlockfree(pFuncDef); };
protected:
PushdownGenerator* mP_0_0;
PushdownGenerator* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Default
    switch(n) { 
    case 0:     res=DoTypeCast<PushdownGenerator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<PushdownGenerator>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Default
    PushdownBlockfree(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function PushdownConstructController*/
class Rti116PushdownConstructController : public Function { 
public:
Rti116PushdownConstructController(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti116PushdownConstructController(pFuncDef); };
protected:
PushdownGenerator* mP_0_0;
System* mP_0_1;
PushdownGenerator* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant Default
    switch(n) { 
    case 0:     res=DoTypeCast<PushdownGenerator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<System>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<PushdownGenerator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant Default
    PushdownConstructController(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function RemoveIoDummyStates*/
class Rti117RemoveIoDummyStates : public Function { 
public:
Rti117RemoveIoDummyStates(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti117RemoveIoDummyStates(pFuncDef); };
protected:
IoSystem* mP_0_0;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant RemoveIoDummyStates(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<IoSystem>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant RemoveIoDummyStates(GArg)
    RemoveIoDummyStates(*mP_0_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SelfLoop*/
class Rti118SelfLoop : public Function { 
public:
Rti118SelfLoop(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti118SelfLoop(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant SelfLoop(G,Sigma)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant SelfLoop(G,Sigma)
    SelfLoop(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function aStateMin*/
class Rti119aStateMin : public Function { 
public:
Rti119aStateMin(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti119aStateMin(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_1_0;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant GRes:=StateMin(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant G:=StateMin(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant GRes:=StateMin(GArg)
    aStateMin(*mP_0_0 ,*mP_0_1); break; };
  case 1: { // variant G:=StateMin(G)
    aStateMin(*mP_1_0); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function StronglyCoaccessible*/
class Rti120StronglyCoaccessible : public Function { 
public:
Rti120StronglyCoaccessible(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti120StronglyCoaccessible(pFuncDef); };
protected:
MtcSystem* mP_0_0;
MtcSystem* mP_1_0;
MtcSystem* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant G:=StronglyCoAcc(G)
    switch(n) { 
    case 0:     res=DoTypeCast<MtcSystem>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant GRes=StronglyCoAcc(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<MtcSystem>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<MtcSystem>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant G:=StronglyCoAcc(G)
    StronglyCoaccessible(*mP_0_0); break; };
  case 1: { // variant GRes=StronglyCoAcc(GArg)
    StronglyCoaccessible(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function StronglyTrim*/
class Rti121StronglyTrim : public Function { 
public:
Rti121StronglyTrim(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti121StronglyTrim(pFuncDef); };
protected:
MtcSystem* mP_0_0;
MtcSystem* mP_1_0;
MtcSystem* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant G:=StronglyTrim(G)
    switch(n) { 
    case 0:     res=DoTypeCast<MtcSystem>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant GRes=StronglyTrim(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<MtcSystem>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<MtcSystem>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant G:=StronglyTrim(G)
    StronglyTrim(*mP_0_0); break; };
  case 1: { // variant GRes=StronglyTrim(GArg)
    StronglyTrim(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SupConClosed*/
class Rti122SupConClosed : public Function { 
public:
Rti122SupConClosed(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti122SupConClosed(pFuncDef); };
protected:
System* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
Generator* mP_1_0;
EventSet* mP_1_1;
Generator* mP_1_2;
Generator* mP_1_3;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant SupC(GPlant,GSpec,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant SupC(GPlant,AContr,GSpec,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_1_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_1_3); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant SupC(GPlant,GSpec,GSupervisor)
    SupConClosed(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant SupC(GPlant,AContr,GSpec,GSupervisor)
    SupConClosed(*mP_1_0 ,*mP_1_1 ,*mP_1_2 ,*mP_1_3); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SupConCmplClosed*/
class Rti123SupConCmplClosed : public Function { 
public:
Rti123SupConCmplClosed(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti123SupConCmplClosed(pFuncDef); };
protected:
System* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
Generator* mP_1_0;
EventSet* mP_1_1;
Generator* mP_1_2;
Generator* mP_1_3;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant SupCC(GPlant,GSpec,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant SupCC(GPlant,AContr,GSpec,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_1_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_1_3); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant SupCC(GPlant,GSpec,GSupervisor)
    SupConCmplClosed(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant SupCC(GPlant,AContr,GSpec,GSupervisor)
    SupConCmplClosed(*mP_1_0 ,*mP_1_1 ,*mP_1_2 ,*mP_1_3); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SupConCmplNB*/
class Rti124SupConCmplNB : public Function { 
public:
Rti124SupConCmplNB(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti124SupConCmplNB(pFuncDef); };
protected:
System* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
Generator* mP_1_0;
EventSet* mP_1_1;
Generator* mP_1_2;
Generator* mP_1_3;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant SupCC(GPlant,GSpec,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant SupCC(GPlant,AContr,GSpec,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_1_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_1_3); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant SupCC(GPlant,GSpec,GSupervisor)
    SupConCmplNB(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant SupCC(GPlant,AContr,GSpec,GSupervisor)
    SupConCmplNB(*mP_1_0 ,*mP_1_1 ,*mP_1_2 ,*mP_1_3); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SupConNB*/
class Rti125SupConNB : public Function { 
public:
Rti125SupConNB(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti125SupConNB(pFuncDef); };
protected:
System* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
Generator* mP_1_0;
EventSet* mP_1_1;
Generator* mP_1_2;
Generator* mP_1_3;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant SupC(GPlant,GSpec,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant SupC(GPlant,AContr,GSpec,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_1_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_1_3); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant SupC(GPlant,GSpec,GSupervisor)
    SupConNB(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant SupC(GPlant,AContr,GSpec,GSupervisor)
    SupConNB(*mP_1_0 ,*mP_1_1 ,*mP_1_2 ,*mP_1_3); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SupConNormClosed*/
class Rti126SupConNormClosed : public Function { 
public:
Rti126SupConNormClosed(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti126SupConNormClosed(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
EventSet* mP_0_2;
Generator* mP_0_3;
Generator* mP_0_4;
System* mP_1_0;
Generator* mP_1_1;
Generator* mP_1_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant SupCN(L,E,ACtrl,AObs,GRes)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_0_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_0_3); break; 
    case 4:     res=DoTypeCast<Generator>(4, mP_0_4); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant SupCN(GPlant,GSpec,GRes)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_1_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant SupCN(L,E,ACtrl,AObs,GRes)
    SupConNormClosed(*mP_0_0 ,*mP_0_1 ,*mP_0_2 ,*mP_0_3 ,*mP_0_4); break; };
  case 1: { // variant SupCN(GPlant,GSpec,GRes)
    SupConNormClosed(*mP_1_0 ,*mP_1_1 ,*mP_1_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SupConNormCmplNB*/
class Rti127SupConNormCmplNB : public Function { 
public:
Rti127SupConNormCmplNB(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti127SupConNormCmplNB(pFuncDef); };
protected:
System* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
Generator* mP_1_0;
EventSet* mP_1_1;
EventSet* mP_1_2;
Generator* mP_1_3;
Generator* mP_1_4;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant SupCNC(GPlant,GSpec,GRes)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant SupCNC(GPlant,AContr,AObs,GSpec,GRes)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_1_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_1_3); break; 
    case 4:     res=DoTypeCast<Generator>(4, mP_1_4); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant SupCNC(GPlant,GSpec,GRes)
    SupConNormCmplNB(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant SupCNC(GPlant,AContr,AObs,GSpec,GRes)
    SupConNormCmplNB(*mP_1_0 ,*mP_1_1 ,*mP_1_2 ,*mP_1_3 ,*mP_1_4); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SupConNormNB*/
class Rti128SupConNormNB : public Function { 
public:
Rti128SupConNormNB(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti128SupConNormNB(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
EventSet* mP_0_2;
Generator* mP_0_3;
Generator* mP_0_4;
System* mP_1_0;
Generator* mP_1_1;
Generator* mP_1_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant SupCN(L,E,ACtrl,AObs,GRes)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_0_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_0_3); break; 
    case 4:     res=DoTypeCast<Generator>(4, mP_0_4); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant SupCN(GPlant,GSpec,GRes)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_1_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant SupCN(L,E,ACtrl,AObs,GRes)
    SupConNormNB(*mP_0_0 ,*mP_0_1 ,*mP_0_2 ,*mP_0_3 ,*mP_0_4); break; };
  case 1: { // variant SupCN(GPlant,GSpec,GRes)
    SupConNormNB(*mP_1_0 ,*mP_1_1 ,*mP_1_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SupConditionalControllable*/
class Rti129SupConditionalControllable : public Function { 
public:
Rti129SupConditionalControllable(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti129SupConditionalControllable(pFuncDef); };
protected:
System* mP_0_0;
GeneratorVector* mP_0_1;
EventSet* mP_0_2;
EventSet* mP_0_3;
GeneratorVector* mP_0_4;
Generator* mP_0_5;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant SupConditionalControllable(SpecGen,genVect,ACntrl,supVector,Coord)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<GeneratorVector>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_0_2); break; 
    case 3:     res=DoTypeCast<EventSet>(3, mP_0_3); break; 
    case 4:     res=DoTypeCast<GeneratorVector>(4, mP_0_4); break; 
    case 5:     res=DoTypeCast<Generator>(5, mP_0_5); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant SupConditionalControllable(SpecGen,genVect,ACntrl,supVector,Coord)
    SupConditionalControllable(*mP_0_0 ,*mP_0_1 ,*mP_0_2 ,*mP_0_3 ,*mP_0_4 ,*mP_0_5); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SupNorm*/
class Rti130SupNorm : public Function { 
public:
Rti130SupNorm(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti130SupNorm(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
Generator* mP_0_2;
Generator* mP_0_3;
System* mP_1_0;
Generator* mP_1_1;
Generator* mP_1_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant SupN(L,AObs,K,GRes)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_0_3); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant SupN(GPlant,GCand,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_1_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant SupN(L,AObs,K,GRes)
    SupNorm(*mP_0_0 ,*mP_0_1 ,*mP_0_2 ,*mP_0_3); break; };
  case 1: { // variant SupN(GPlant,GCand,GSupervisor)
    SupNorm(*mP_1_0 ,*mP_1_1 ,*mP_1_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SupNormClosed*/
class Rti131SupNormClosed : public Function { 
public:
Rti131SupNormClosed(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti131SupNormClosed(pFuncDef); };
protected:
Generator* mP_0_0;
EventSet* mP_0_1;
Generator* mP_0_2;
Generator* mP_0_3;
System* mP_1_0;
Generator* mP_1_1;
Generator* mP_1_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant SupN(L,K,AObs,GRes)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    case 3:     res=DoTypeCast<Generator>(3, mP_0_3); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant SupN(GPlant,GCand,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_1_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant SupN(L,K,AObs,GRes)
    SupNormClosed(*mP_0_0 ,*mP_0_1 ,*mP_0_2 ,*mP_0_3); break; };
  case 1: { // variant SupN(GPlant,GCand,GSupervisor)
    SupNormClosed(*mP_1_0 ,*mP_1_1 ,*mP_1_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SupReduce*/
class Rti132SupReduce : public Function { 
public:
Rti132SupReduce(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti132SupReduce(pFuncDef); };
protected:
System* mP_0_0;
System* mP_0_1;
System* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant SupReduce(GPlant,GSup,GReducedSup)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<System>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<System>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant SupReduce(GPlant,GSup,GReducedSup)
    SupReduce(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SupRelativelyPrefixClosed*/
class Rti133SupRelativelyPrefixClosed : public Function { 
public:
Rti133SupRelativelyPrefixClosed(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti133SupRelativelyPrefixClosed(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant SupR(GPlant,GSpec,GRes)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant SupR(GPlant,GSpec,GRes)
    SupRelativelyPrefixClosed(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function SupTconNB*/
class Rti134SupTconNB : public Function { 
public:
Rti134SupTconNB(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti134SupTconNB(pFuncDef); };
protected:
System* mP_0_0;
Generator* mP_0_1;
Generator* mP_0_2;
Generator* mP_1_0;
EventSet* mP_1_1;
EventSet* mP_1_2;
EventSet* mP_1_3;
Generator* mP_1_4;
Generator* mP_1_5;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant SupTc(GPlant,GSpec,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<System>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Generator>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant SupTc(GPlant,AContr,GSpec,GSupervisor)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<EventSet>(1, mP_1_1); break; 
    case 2:     res=DoTypeCast<EventSet>(2, mP_1_2); break; 
    case 3:     res=DoTypeCast<EventSet>(3, mP_1_3); break; 
    case 4:     res=DoTypeCast<Generator>(4, mP_1_4); break; 
    case 5:     res=DoTypeCast<Generator>(5, mP_1_5); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant SupTc(GPlant,GSpec,GSupervisor)
    SupTconNB(*mP_0_0 ,*mP_0_1 ,*mP_0_2); break; };
  case 1: { // variant SupTc(GPlant,AContr,GSpec,GSupervisor)
    SupTconNB(*mP_1_0 ,*mP_1_1 ,*mP_1_2 ,*mP_1_3 ,*mP_1_4 ,*mP_1_5); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function Trim*/
class Rti135Trim : public Function { 
public:
Rti135Trim(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti135Trim(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant G:=Trim(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant GRes=Trim(GArg)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant G:=Trim(G)
    Trim(*mP_0_0); break; };
  case 1: { // variant GRes=Trim(GArg)
    Trim(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function UniqueInit*/
class Rti136UniqueInit : public Function { 
public:
Rti136UniqueInit(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti136UniqueInit(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_1_0;
Generator* mP_1_1;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant UniqueInit(G)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    default: break; 
    } 
    break; 
  } 
  case 1: { // variant UniqueInit(G,GRes)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_1_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_1_1); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant UniqueInit(G)
    UniqueInit(*mP_0_0); break; };
  case 1: { // variant UniqueInit(G,GRes)
    UniqueInit(*mP_1_0 ,*mP_1_1); break; };
  default: break; 
  }; 
}; 
};
/* Function class for C++ function ccTrim*/
class Rti137ccTrim : public Function { 
public:
Rti137ccTrim(const FunctionDefinition* fdef) : Function(fdef) {};
virtual Function* New(void) const { return new Rti137ccTrim(pFuncDef); };
protected:
Generator* mP_0_0;
Generator* mP_0_1;
Boolean* mP_0_2;
virtual bool DoTypeCheck(int n) {
  bool res=false;
  switch(mVariantIndex) { 
  case 0: { // variant ccTrim(gen,trimGen)
    switch(n) { 
    case 0:     res=DoTypeCast<Generator>(0, mP_0_0); break; 
    case 1:     res=DoTypeCast<Generator>(1, mP_0_1); break; 
    case 2:     res=DoTypeCast<Boolean>(2, mP_0_2); break; 
    default: break; 
    } 
    break; 
  } 
  default: break; 
  } 
  return res;
};
virtual void DoExecute(void) {
  switch(mVariantIndex) { 
  case 0: { // variant ccTrim(gen,trimGen)
    *(mP_0_2->CReference()) = ccTrim(*mP_0_0 ,*mP_0_1); break; };
  default: break; 
  }; 
}; 
};
} // namespace
